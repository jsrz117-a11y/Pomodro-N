<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Pomodoro Widget</title>

<style>
  :root {
    --pink: #C14C8A;
    --white: #FEFEFE;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    color: var(--white);
  }

  .widget {
    text-align: center;
    width: 320px;

    /* rounded container */
    background: #C14C8A;
    padding: 24px;
    border-radius: 12px;
  }

  /* TOP TABS ----------------------------------------------------- */

  .tabs {
    display: inline-flex;
    gap: 8px;
    margin-bottom: 32px;
  }

  .tab {
    padding: 8px 18px;
    border-radius: 999px;
    border: 2px solid var(--white);
    background: transparent;
    color: var(--white);
    font-size: 14px;
    cursor: pointer;
  }

  .tab.active {
    background: rgba(254, 254, 254, 0.25);
    border-color: transparent;
  }

  .tab:focus-visible {
    outline: 2px solid var(--white);
    outline-offset: 2px;
  }

  /* TIMER -------------------------------------------------------- */

  .timer {
    display: flex;
    flex-direction: row;       /* horizontal layout */
    align-items: center;
    justify-content: center;
    font-weight: 800;
    line-height: 1;
  }

  .time-part {
    font-size: 80px;
  }

  /* add colon between minutes and seconds */
  #minutes::after {
    content: ":";
    margin: 0 4px;            /* space between 25 and 00 */
  }

  /* CONTROLS ----------------------------------------------------- */

  .controls-row {
    margin-top: 32px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 16px;
  }

  .icon-button,
  .primary-button {
    border: none;
    cursor: pointer;
    font-size: 18px;
    color: var(--white);
    background: rgba(254, 254, 254, 0.25);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .icon-button {
    width: 52px;
    height: 52px;
    border-radius: 999px;
  }

  .primary-button {
    width: 110px;
    height: 52px;
    border-radius: 999px;
    font-size: 20px;
  }

  .icon-button:focus-visible,
  .primary-button:focus-visible {
    outline: 2px solid var(--white);
    outline-offset: 2px;
  }

  /* MORE MENU ---------------------------------------------------- */

  .more-menu {
    position: absolute;
    bottom: 120px;
    left: 50%;
    transform: translateX(-120px);

    /* SOLID, NON-GLASS BACKGROUND */
    background: #fefefe;          /* solid white */
    border: 1px solid #e0e0e0;
    padding: 8px;
    border-radius: 12px;
    display: none;
    flex-direction: column;
    gap: 4px;

    /* make sure the blur is completely gone */
    backdrop-filter: none;
  }

  .more-menu button {
    border: none;
    background: #f5f5f5;         /* solid grey button */
    color: #7d2057;              /* matches your pink tone */
    padding: 6px 12px;
    border-radius: 999px;
    font-size: 14px;
    cursor: pointer;
    text-align: left;
  }

  /* SETTINGS MODAL ---------------------------------------------- */

  .overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.4);
    display: none;
    align-items: center;
    justify-content: center;
    padding: 16px;
    z-index: 10;
  }

  .settings-modal {
    background: #fefefe;
    color: #7d2057; /* slightly darker text that matches pink tone */
    border-radius: 16px;
    padding: 20px 22px;
    max-width: 360px;
    width: 100%;
  }

  .settings-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
  }

  .settings-title {
    font-weight: 700;
    font-size: 20px;
  }

  .close-btn {
    border: none;
    background: transparent;
    font-size: 20px;
    cursor: pointer;
    color: #7d2057;
  }

  .setting-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 8px 0;
    font-size: 14px;
  }

  .setting-row label {
    margin-right: 12px;
  }

  .setting-row input[type="number"] {
    width: 70px;
    padding: 4px 6px;
    border-radius: 8px;
    border: 1px solid #d7d7d7;
    font-size: 14px;
  }

  .save-btn {
    margin-top: 16px;
    width: 100%;
    border-radius: 999px;
    border: none;
    padding: 10px 0;
    cursor: pointer;
    background: #C14C8A;
    color: #FEFEFE;
    font-weight: 600;
    font-size: 15px;
  }

  .save-btn:focus-visible {
    outline: 2px solid #C14C8A;
    outline-offset: 2px;
  }
</style>
</head>
<body>

<div class="widget">
  <!-- MODE TABS -->
  <div class="tabs">
    <button class="tab active" data-mode="focus">Focus</button>
    <button class="tab" data-mode="short">Break</button>
    <button class="tab" data-mode="long">Long B</button>
  </div>

  <!-- TIMER -->
  <div class="timer">
    <div id="minutes" class="time-part">25</div>
    <div id="seconds" class="time-part">00</div>
  </div>

  <!-- CONTROLS -->
  <div class="controls-row">
    <button class="icon-button" id="moreBtn" aria-label="More options">⋯</button>
    <button class="primary-button" id="playPauseBtn" aria-label="Start timer">▶</button>
    <button class="icon-button" id="nextBtn" aria-label="Next mode">⏭</button>
  </div>

  <!-- 3 DOTS POPUP -->
  <div class="more-menu" id="moreMenu">
    <button id="menuResetBtn">Reset</button>
    <button id="menuSettingsBtn">Settings</button>
  </div>
</div>

<!-- BELL SOUND -->
<audio id="bellSound" src="bell.mp3" preload="auto"></audio>

<!-- SETTINGS MODAL -->
<div class="overlay" id="settingsOverlay">
  <div class="settings-modal">
    <div class="settings-header">
      <div class="settings-title">Settings</div>
      <button class="close-btn" id="closeSettingsBtn">✕</button>
    </div>

    <div class="setting-row">
      <label for="focusInput">Focus length (min)</label>
      <input type="number" id="focusInput" min="1" value="25">
    </div>
    <div class="setting-row">
      <label for="shortInput">Short break (min)</label>
      <input type="number" id="shortInput" min="1" value="5">
    </div>
    <div class="setting-row">
      <label for="longInput">Long break (min)</label>
      <input type="number" id="longInput" min="1" value="15">
    </div>
    <!-- NEW: how many short breaks before long break -->
    <div class="setting-row">
      <label for="breakCountInput">Short breaks before long</label>
      <input type="number" id="breakCountInput" min="1" value="3">
    </div>

    <button class="save-btn" id="saveSettingsBtn">Save</button>
  </div>
</div>

<script>
  // --- STATE --------------------------------------------------------
  const modes = {
    focus: 25,
    short: 5,
    long: 15
  };

  let currentMode = "focus";
  let totalSeconds = modes[currentMode] * 60;
  let timerId = null;
  let isRunning = false;

  // track completed short breaks → long break
  let shortBreakCounter = 0;
  let shortBreaksBeforeLong = 3;

  // real-time based end timestamp (ms) + storage key
  let endTimestamp = null;
  const STORAGE_KEY = "pomodoro_state_v1";

  // --- ELEMENTS -----------------------------------------------------
  const minutesEl = document.getElementById("minutes");
  const secondsEl = document.getElementById("seconds");
  const playPauseBtn = document.getElementById("playPauseBtn");
  const moreBtn = document.getElementById("moreBtn");
  const moreMenu = document.getElementById("moreMenu");

  const tabs = document.querySelectorAll(".tab");

  const settingsOverlay = document.getElementById("settingsOverlay");
  const closeSettingsBtn = document.getElementById("closeSettingsBtn");
  const saveSettingsBtn = document.getElementById("saveSettingsBtn");
  const focusInput = document.getElementById("focusInput");
  const shortInput = document.getElementById("shortInput");
  const longInput = document.getElementById("longInput");
  const breakCountInput = document.getElementById("breakCountInput");

  const menuResetBtn = document.getElementById("menuResetBtn");
  const menuSettingsBtn = document.getElementById("menuSettingsBtn");

  const bellSound = document.getElementById("bellSound");

  // --- HELPERS: DISPLAY ---------------------------------------------

  function updateDisplay() {
    const m = Math.floor(totalSeconds / 60);
    const s = totalSeconds % 60;

    minutesEl.textContent = String(m).padStart(2, "0");
    secondsEl.textContent = String(s).padStart(2, "0");
  }

  // --- PERSISTENCE (localStorage) -----------------------------------

  function saveState() {
    const state = {
      modes,
      currentMode,
      totalSeconds,
      isRunning,
      endTimestamp,
      shortBreakCounter,
      shortBreaksBeforeLong
    };
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch (e) {
      // ignore if storage not available
    }
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;

      const state = JSON.parse(raw);

      if (state.modes) {
        modes.focus = state.modes.focus ?? modes.focus;
        modes.short = state.modes.short ?? modes.short;
        modes.long = state.modes.long ?? modes.long;
      }

      currentMode = state.currentMode || "focus";
      totalSeconds = state.totalSeconds ?? modes[currentMode] * 60;
      isRunning = !!state.isRunning;
      endTimestamp = state.endTimestamp ?? null;

      shortBreakCounter = state.shortBreakCounter ?? 0;
      shortBreaksBeforeLong = state.shortBreaksBeforeLong ?? 3;

      // update active tab
      tabs.forEach(tab => {
        tab.classList.toggle("active", tab.dataset.mode === currentMode);
      });

      updateDisplay();

      // if it was running and end time is still in future, resume ticking
      if (isRunning && endTimestamp && endTimestamp > Date.now()) {
        resumeTimerFromEndTime();
      } else if (endTimestamp && endTimestamp <= Date.now()) {
        // already finished while away
        totalSeconds = 0;
        isRunning = false;
        endTimestamp = null;
        playPauseBtn.textContent = "▶";
        updateDisplay();
        saveState();
      }
    } catch (e) {
      // corrupted state; ignore
    }
  }

  // --- TIMER CORE (real-time based) ---------------------------------

  // decides what to do when a session finishes
  function handleSessionComplete() {
    if (currentMode === "focus") {
      // focus finished → choose which break to take based on how many short breaks are done
      if (shortBreakCounter >= shortBreaksBeforeLong) {
        // we've already done enough short breaks → take a long break, reset counter
        shortBreakCounter = 0;
        setMode("long");
        startTimer(); // auto-start long break
      } else {
        // still haven't reached the target → short break
        setMode("short");
        startTimer(); // auto-start short break
      }
    } else if (currentMode === "short") {
      // short break finished → count it, then go to focus (do not auto-start)
      shortBreakCounter++;
      setMode("focus");
      // user must press play to start focus
    } else if (currentMode === "long") {
      // long break finished → back to focus, do not auto-start
      setMode("focus");
    }
  }

  function resumeTimerFromEndTime() {
    clearInterval(timerId);

    const tick = () => {
      const now = Date.now();
      const diffMs = endTimestamp - now;
      const remaining = Math.round(diffMs / 1000);

      if (remaining <= 0) {
        clearInterval(timerId);
        totalSeconds = 0;
        updateDisplay();
        isRunning = false;
        endTimestamp = null;
        playPauseBtn.textContent = "▶";

        // Play bell sound when finished
        if (bellSound) {
          bellSound.currentTime = 0;
          bellSound.play().catch(() => {
            // ignore autoplay errors
          });
        }

        // move to next mode according to logic
        handleSessionComplete();
        saveState();
        return;
      }

      totalSeconds = remaining;
      updateDisplay();
    };

    tick(); // immediate update
    timerId = setInterval(tick, 1000);
  }

  function setMode(mode) {
    currentMode = mode;
    clearInterval(timerId);
    isRunning = false;
    endTimestamp = null;
    totalSeconds = modes[mode] * 60;
    playPauseBtn.textContent = "▶";
    updateDisplay();

    tabs.forEach(tab => {
      tab.classList.toggle("active", tab.dataset.mode === mode);
    });

    saveState();
  }

  function startTimer() {
    if (isRunning) return;

    if (totalSeconds <= 0) {
      totalSeconds = modes[currentMode] * 60;
    }

    isRunning = true;
    playPauseBtn.textContent = "⏸";

    endTimestamp = Date.now() + totalSeconds * 1000;

    saveState();
    resumeTimerFromEndTime();
  }

  function pauseTimer() {
    if (!isRunning) return;

    if (endTimestamp) {
      const remaining = Math.max(
        0,
        Math.round((endTimestamp - Date.now()) / 1000)
      );
      totalSeconds = remaining;
    }

    clearInterval(timerId);
    isRunning = false;
    endTimestamp = null;
    playPauseBtn.textContent = "▶";
    updateDisplay();
    saveState();
  }

  function resetTimer() {
    clearInterval(timerId);
    isRunning = false;
    endTimestamp = null;
    totalSeconds = modes[currentMode] * 60;
    playPauseBtn.textContent = "▶";
    updateDisplay();
    saveState();
  }

  // NEXT BUTTON: same logic as auto-advance, but NO auto-start
  function goToNextMode() {
    if (currentMode === "focus") {
      // manually skip a focus → go to the same break type logic, but don't start it
      if (shortBreakCounter >= shortBreaksBeforeLong) {
        shortBreakCounter = 0;
        setMode("long");
      } else {
        setMode("short");
      }
    } else if (currentMode === "short") {
      // manually skip a short break → count it as done, go to focus
      shortBreakCounter++;
      setMode("focus");
    } else if (currentMode === "long") {
      // manually skip long → back to focus
      setMode("focus");
    }
  }

  // --- SETTINGS ----------------------------------------------------

  function openSettings() {
    focusInput.value = modes.focus;
    shortInput.value = modes.short;
    longInput.value = modes.long;
    breakCountInput.value = shortBreaksBeforeLong;

    settingsOverlay.style.display = "flex";
  }

  function closeSettings() {
    settingsOverlay.style.display = "none";
  }

  function saveSettings() {
    const f = parseInt(focusInput.value, 10);
    const s = parseInt(shortInput.value, 10);
    const l = parseInt(longInput.value, 10);
    const bc = parseInt(breakCountInput.value, 10);

    if (f > 0) modes.focus = f;
    if (s > 0) modes.short = s;
    if (l > 0) modes.long = l;
    if (bc > 0) shortBreaksBeforeLong = bc;

    if (!isRunning) {
      totalSeconds = modes[currentMode] * 60;
      updateDisplay();
    }

    saveState();
    closeSettings();
  }

  // --- MENU & EVENTS -----------------------------------------------

  playPauseBtn.addEventListener("click", () => {
    if (isRunning) pauseTimer();
    else startTimer();
  });

  document.getElementById("nextBtn").addEventListener("click", goToNextMode);

  tabs.forEach(tab => {
    tab.addEventListener("click", () => {
      setMode(tab.dataset.mode);
    });
  });

  moreBtn.addEventListener("click", () => {
    const isVisible = moreMenu.style.display === "flex";
    moreMenu.style.display = isVisible ? "none" : "flex";
  });

  // menu items
  menuResetBtn.addEventListener("click", () => {
    resetTimer();
    moreMenu.style.display = "none";
  });

  menuSettingsBtn.addEventListener("click", () => {
    moreMenu.style.display = "none";
    openSettings();
  });

  // settings overlay events
  closeSettingsBtn.addEventListener("click", closeSettings);
  saveSettingsBtn.addEventListener("click", saveSettings);

  settingsOverlay.addEventListener("click", (e) => {
    if (e.target === settingsOverlay) closeSettings();
  });

  // initial load
  loadState();
  updateDisplay();
</script>

</body>
</html>
